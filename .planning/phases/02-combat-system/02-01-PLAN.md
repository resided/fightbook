---
phase: 02-combat-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: true
requirements: [CPU-01, CPU-02, CPU-03, CPU-04, CPU-05, CPU-06]
must_haves:
  truths:
    - "User can select their fighter to fight CPU opponent"
    - "User's LLM receives battle context and decides moves"
    - "CPU makes basic strategic decisions"
    - "Fight runs with real-time scrolling text"
    - "Winner declared at end of fight"
  artifacts:
    - path: "src/lib/cpuOpponent.ts"
      provides: "CPU fighter creation and basic AI"
      exports: ["createCpuFighter", "CpuFighter", "getCpuDecision"]
    - path: "src/lib/llmClient.ts"
      provides: "LLM integration for user moves"
      exports: ["getLlmDecision", "buildBattlePrompt"]
    - path: "src/components/FightSelect.tsx"
      provides: "Fight selection UI"
      min_lines: 50
    - path: "src/engine/FightEngine.ts"
      provides: "Updated engine with LLM and CPU support"
      adds: "llmCallback, cpuCallback, mixedMode"
  key_links:
    - from: "src/components/TextFight.tsx"
      to: "src/lib/cpuOpponent.ts"
      via: "createCpuFighter()"
      pattern: "createCpuFighter"
    - from: "src/engine/FightEngine.ts"
      to: "src/lib/llmClient.ts"
      via: "getLlmDecision()"
      pattern: "getLlmDecision"
    - from: "src/components/FightSelect.tsx"
      to: "src/components/TextFight.tsx"
      via: "navigate to fight"
      pattern: "TextFight.*agent"
user_setup: []
---

<objective>
Build CPU opponent system, fight selection UI, and LLM integration for user moves.

Purpose: Users can select their fighter and fight against a CPU opponent. User's LLM decides moves while CPU uses simple AI.
Output: CPU opponent system, fight selection, LLM decision-making integration.
</objective>

<context>
@/project/src/types/agent.ts
@/project/src/types/fight.ts
@/project/src/engine/FightEngine.ts
@/project/src/components/TextFight.tsx
@/project/src/lib/storage.ts
@/project/src/lib/fighterStorage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CPU opponent system</name>
  <files>src/lib/cpuOpponent.ts</files>
  <action>
    Create src/lib/cpuOpponent.ts:
    1. Create CpuFighter interface extending FighterStats with difficulty level
    2. createCpuFighter(name, difficulty): Creates CPU fighter with stats scaled by difficulty (easy/medium/hard)
    3. getCpuDecision(actor, target, context): Simple decision AI that picks techniques based on:
       - Position (standing/clinch/ground)
       - Health differential (trailing fighter becomes more aggressive)
       - Stamina levels (tired = defensive)
       - Randomness factor based on difficulty
    4. Export CPU_DIFFICULTIES with stat multipliers

    The CPU should make decisions similar to FightEngine.selectTechnique but simplified for basic AI.
  </action>
  <verify>cpuOpponent.ts exists with createCpuFighter and getCpuDecision exported</verify>
  <done>CPU opponent can be created with configurable difficulty</done>
</task>

<task type="auto">
  <name>Task 2: Create LLM client integration</name>
  <files>src/lib/llmClient.ts</files>
  <action>
    Create src/lib/llmClient.ts:
    1. buildBattlePrompt(actor, target, gameState): Builds detailed prompt with:
       - Current round, time remaining
       - Both fighters' health/stamina/position
       - Recent fight history (last 3 actions)
       - Available techniques by position
       - Instructions to respond with JSON: {technique: string, reasoning: string}
    2. getLlmDecision(agent, opponent, gameState, apiKey, provider): 
       - Calls OpenAI or Anthropic API with battle prompt
       - Parses response to extract technique choice
       - Falls back to random technique on error
       - Add 5-second timeout to prevent hanging
    3. Map technique names from LLM response to actual Technique objects from fight.ts

    IMPORTANT: Use user's stored API key from their fighter record to make calls.
  </action>
  <verify>llmClient.ts exists with getLlmDecision and buildBattlePrompt exported</verify>
  <done>User's LLM can receive battle state and return move decisions</done>
</task>

<task type="auto">
  <name>Task 3: Create fight selection UI</name>
  <files>src/components/FightSelect.tsx</files>
  <action>
    Create src/components/FightSelect.tsx:
    1. Load user's fighters from fighterStorage.getFighters()
    2. Display grid of user's fighters with stats preview (Power/Speed/Defense)
    3. Each card shows: name, wins/losses record, overall rating
    4. "Fight CPU" button on each card that:
       - Creates CPU opponent at medium difficulty
       - Launches TextFight with user fighter vs CPU
    5. Difficulty selector (Easy/Medium/Hard) before starting fight
    6. Empty state: "No fighters. Register your first AI agent first!"
    7. Use existing UI components (Card, Button, Badge from shadcn)

    On "Fight CPU" click, navigate to TextFight with both fighters.
  </action>
  <verify>Component renders user's fighters, shows fight button, difficulty selector works</verify>
  <done>User can select fighter and start fight against CPU</done>
</task>

<task type="auto">
  <name>Task 4: Update FightEngine for LLM and CPU callbacks</name>
  <files>src/engine/FightEngine.ts</files>
  <action>
    Update src/engine/FightEngine.ts:
    1. Add constructor options:
       - llmCallback?: (actor, target, gameState) => Promise<string> - returns technique name
       - cpuCallback?: (actor, target, gameState) => string - for CPU decisions  
       - mixedMode: boolean - if true, one fighter uses LLM, other uses callback
    2. Modify generateAction to:
       - If mixedMode and actor is LLM fighter: await llmCallback() for technique
       - If mixedMode and actor is CPU fighter: use cpuCallback() for technique
       - Otherwise use existing selectTechnique (simulated AI vs AI)
    3. Add getGameState() method that returns simplified state for LLM context:
       - { round, timeRemaining, myHealth, myStamina, myPosition, oppHealth, oppStamina, oppPosition, recentActions }

    This allows TextFight to pass LLM and CPU callbacks based on who's fighting.
  </action>
  <verify>FightEngine accepts llmCallback and cpuCallback in constructor</verify>
  <done>FightEngine can delegate decisions to LLM or CPU callback</done>
</task>

<task type="auto">
  <name>Task 5: Integrate LLM/CPU into TextFight</name>
  <files>src/components/TextFight.tsx</files>
  <action>
    Update src/components/TextFight.tsx:
    1. Detect if agent2 is CPU (has special 'cpu' id or flag)
    2. If agent2 is CPU:
       - Pass cpuCallback to FightEngine using getCpuDecision
       - Pass mixedMode=true with agent1 as LLM fighter
    3. If both are user fighters:
       - Pass llmCallback for agent1 (using agent1's API key)
       - Pass llmCallback for agent2 (using agent2's API key)
    4. Add loading state while LLM responds (show "Thinking..." in UI)
    5. Handle LLM timeout/error gracefully - fall back to random technique

    The key: TextFight receives fighters, determines which are CPU, sets up callbacks.
  </action>
  <verify>TextFight initializes FightEngine with appropriate callbacks based on fighter types</verify>
  <done>Fight uses LLM for user fighters and CPU AI for CPU opponent</done>
</task>

</tasks>

<verification>
[ ] cpuOpponent.ts creates CPU fighters and provides decision function
[ ] llmClient.ts can call user's LLM API with battle context
[ ] FightSelect.tsx shows user's fighters with "Fight CPU" button
[ ] FightEngine accepts llmCallback and cpuCallback
[ ] TextFight passes correct callbacks based on fighter types
[ ] Fight runs with real-time text scrolling (existing)
[ ] Winner declared at end (existing)
</verification>

<success_criteria>
User can select their fighter, fight against CPU opponent, watch real-time text battle where user's LLM makes decisions. CPU makes basic strategic decisions. Winner is declared at end.
</success_criteria>

<output>
After completion, create `.planning/phases/02-combat-system/02-01-SUMMARY.md`
</output>
